{"version":3,"sources":["type.ts"],"names":["TypeTranspiler","TypeTranspiler.constructor","TypeTranspiler.visitNode"],"mappings":"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","file":"type.js","sourceRoot":"/Users/vsavkin/projects/ts2dart/","sourcesContent":["/// <reference path='../node_modules/typescript/bin/typescript.d.ts' />\nimport ts = require('typescript');\nimport base = require('./base');\nimport ts2dart = require('./main');\n\nclass TypeTranspiler extends base.TranspilerStep {\n  constructor(tr: ts2dart.Transpiler) { super(tr); }\n\n  visitNode(node: ts.Node): boolean {\n    switch (node.kind) {\n      case ts.SyntaxKind.TypeLiteral:\n        // Dart doesn't support type literals.\n        this.emit('dynamic');\n        break;\n      case ts.SyntaxKind.UnionType:\n        this.emit('dynamic /*');\n        this.visitList((<ts.UnionTypeNode>node).types, \"|\");\n        this.emit('*/');\n        break;\n      case ts.SyntaxKind.TypeReference:\n        var typeRef = <ts.TypeReferenceNode>node;\n        this.visitTypeName(typeRef.typeName);\n        this.maybeVisitTypeArguments(typeRef);\n        break;\n      case ts.SyntaxKind.TypeAssertionExpression:\n        var typeAssertExpr = <ts.TypeAssertion>node;\n        this.emit('(');\n        this.visit(typeAssertExpr.expression);\n        this.emit('as');\n        this.visit(typeAssertExpr.type);\n        this.emit(')');\n        break;\n      case ts.SyntaxKind.TypeParameter:\n        var typeParam = <ts.TypeParameterDeclaration>node;\n        this.visit(typeParam.name);\n        if (typeParam.constraint) {\n          this.emit('extends');\n          this.visit(typeParam.constraint);\n        }\n        break;\n      case ts.SyntaxKind.QualifiedName:\n        var first = <ts.QualifiedName>node;\n        this.visit(first.left);\n        this.emit('.');\n        this.visit(first.right);\n        break;\n      case ts.SyntaxKind.Identifier:\n        var ident = <ts.Identifier>node;\n        this.emit(ident.text);\n        break;\n      case ts.SyntaxKind.NumberKeyword:\n        this.emit('num');\n        break;\n      case ts.SyntaxKind.StringKeyword:\n        this.emit('String');\n        break;\n      case ts.SyntaxKind.VoidKeyword:\n        this.emit('void');\n        break;\n      case ts.SyntaxKind.BooleanKeyword:\n        this.emit('bool');\n        break;\n      case ts.SyntaxKind.AnyKeyword:\n        this.emit('dynamic');\n        break;\n      default:\n        return false;\n    }\n    return true;\n  }\n}\n\nexport = TypeTranspiler;\n"]}