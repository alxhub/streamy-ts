var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path='../node_modules/typescript/bin/typescript.d.ts' />
var ts = require('typescript');
var base = require('./base');
var ImportExportTranspiler = (function (_super) {
    __extends(ImportExportTranspiler, _super);
    function ImportExportTranspiler(tr, generateLibraryName) {
        _super.call(this, tr);
        this.generateLibraryName = generateLibraryName;
    }
    ImportExportTranspiler.prototype.visitNode = function (node) {
        switch (node.kind) {
            case 227 /* SourceFile */:
                if (this.generateLibraryName) {
                    this.emit('library');
                    this.emit(this.getLibraryName());
                    this.emit(';');
                }
                ts.forEachChild(node, this.visit.bind(this));
                break;
            case 1 /* EndOfFileToken */:
                ts.forEachChild(node, this.visit.bind(this));
                break;
            case 209 /* ImportDeclaration */:
                var importDecl = node;
                if (this.isEmptyImport(importDecl))
                    return true;
                this.emit('import');
                this.visitExternalModuleReferenceExpr(importDecl.moduleSpecifier);
                if (importDecl.importClause) {
                    this.visit(importDecl.importClause);
                }
                else {
                    this.reportError(importDecl, 'bare import is unsupported');
                }
                this.emit(';');
                break;
            case 210 /* ImportClause */:
                var importClause = node;
                if (importClause.name)
                    this.visitTypeName(importClause.name);
                if (importClause.namedBindings) {
                    this.visit(importClause.namedBindings);
                }
                break;
            case 211 /* NamespaceImport */:
                var nsImport = node;
                this.emit('as');
                this.visitTypeName(nsImport.name);
                break;
            case 212 /* NamedImports */:
                this.emit('show');
                var used = this.filterImports(node.elements);
                if (used.length === 0) {
                    this.reportError(node, 'internal error, used imports must not be empty');
                }
                this.visitList(used);
                break;
            case 216 /* NamedExports */:
                this.emit('show');
                this.visitList(node.elements);
                break;
            case 213 /* ImportSpecifier */:
            case 217 /* ExportSpecifier */:
                var spec = node;
                if (spec.propertyName)
                    this.visitTypeName(spec.propertyName);
                this.visitTypeName(spec.name);
                break;
            case 215 /* ExportDeclaration */:
                var exportDecl = node;
                this.emit('export');
                if (exportDecl.moduleSpecifier) {
                    this.visitExternalModuleReferenceExpr(exportDecl.moduleSpecifier);
                }
                else {
                    this.reportError(node, 're-exports must have a module URL (export x from "./y").');
                }
                if (exportDecl.exportClause)
                    this.visit(exportDecl.exportClause);
                this.emit(';');
                break;
            case 208 /* ImportEqualsDeclaration */:
                var importEqDecl = node;
                this.emit('import');
                this.visit(importEqDecl.moduleReference);
                this.emit('as');
                this.visitTypeName(importEqDecl.name);
                this.emit(';');
                break;
            case 219 /* ExternalModuleReference */:
                this.visitExternalModuleReferenceExpr(node.expression);
                break;
            default:
                return false;
        }
        return true;
    };
    ImportExportTranspiler.isIgnoredImport = function (e) {
        var name = base.ident(e.name);
        switch (name) {
            case 'CONST':
            case 'CONST_EXPR':
            case 'ABSTRACT':
            case 'IMPLEMENTS':
                return true;
            default:
                return false;
        }
    };
    ImportExportTranspiler.prototype.visitExternalModuleReferenceExpr = function (expr) {
        // TODO: what if this isn't a string literal?
        var moduleName = expr;
        var text = moduleName.text;
        if (text.match(/^\.\//)) {
            // Strip './' to be more Dart-idiomatic.
            text = text.substring(2);
        }
        else if (!text.match(/^\.\.\//)) {
            // Unprefixed imports are package imports.
            text = 'package:' + text;
        }
        moduleName.text = text + '.dart';
        this.visit(expr);
    };
    ImportExportTranspiler.prototype.isEmptyImport = function (n) {
        var bindings = n.importClause.namedBindings;
        if (bindings.kind != 212 /* NamedImports */)
            return false;
        return bindings.elements.every(ImportExportTranspiler.isIgnoredImport);
    };
    ImportExportTranspiler.prototype.filterImports = function (ns) {
        return ns.filter(function (e) { return !ImportExportTranspiler.isIgnoredImport(e); });
    };
    return ImportExportTranspiler;
})(base.TranspilerStep);
module.exports = ImportExportTranspiler;

//# sourceMappingURL=module.js.map