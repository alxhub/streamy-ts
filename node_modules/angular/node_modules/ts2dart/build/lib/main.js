/// <reference path='../typings/fs-extra/fs-extra.d.ts' />
/// <reference path='../typings/node/node.d.ts' />
/// <reference path='../typings/source-map/source-map.d.ts' />
// Use HEAD version of typescript, installed by npm
/// <reference path='../node_modules/typescript/bin/typescript.d.ts' />
require('source-map-support').install();
var SourceMap = require('source-map');
var fs = require('fs');
var fsx = require('fs-extra');
var path = require('path');
var ts = require('typescript');
var CallTranspiler = require('./call');
var DeclarationTranspiler = require('./declaration');
var ExpressionTranspiler = require('./expression');
var ModuleTranspiler = require('./module');
var StatementTranspiler = require('./statement');
var TypeTranspiler = require('./type');
var LiteralTranspiler = require('./literal');
var OPTIONS = {
    target: 2 /* ES6 */,
    module: 1 /* CommonJS */,
    allowNonTsExtensions: true
};
var Transpiler = (function () {
    function Transpiler(options) {
        if (options === void 0) { options = {}; }
        this.options = options;
        // Comments attach to all following AST nodes before the next 'physical' token. Track the earliest
        // offset to avoid printing comments multiple times.
        this.lastCommentIdx = -1;
        this.errors = [];
        this.transpilers = [
            new CallTranspiler(this),
            new DeclarationTranspiler(this),
            new ExpressionTranspiler(this),
            new LiteralTranspiler(this),
            new ModuleTranspiler(this, options.generateLibraryName),
            new StatementTranspiler(this),
            new TypeTranspiler(this),
        ];
    }
    /**
     * Transpiles the given files to Dart.
     * @param fileNames The input files.
     * @param destination Location to write files to. Creates files next to their sources if absent.
     */
    Transpiler.prototype.transpile = function (fileNames, destination) {
        var _this = this;
        var host = this.createCompilerHost(fileNames);
        if (this.options.basePath && destination === undefined) {
            throw new Error('Must have a destination path when a basePath is specified ' +
                this.options.basePath);
        }
        var destinationRoot = destination || this.options.basePath || '';
        var program = ts.createProgram(fileNames, OPTIONS, host);
        program.getSourceFiles()
            .filter(function (sourceFile) { return !sourceFile.fileName.match(/\.d\.ts$/); })
            .forEach(function (f) {
            var dartCode = _this.translate(f);
            var outputFile = _this.getOutputPath(f.fileName, destinationRoot);
            fsx.mkdirsSync(path.dirname(outputFile));
            fs.writeFileSync(outputFile, dartCode);
        });
    };
    Transpiler.prototype.translateProgram = function (program) {
        var _this = this;
        var src = program.getSourceFiles()
            .filter(function (sourceFile) { return !sourceFile.fileName.match(/\.d\.ts$/) &&
            !!sourceFile.fileName.match(/\.[jt]s$/); })
            .map(function (f) { return _this.translate(f); })
            .join('\n');
        return src;
    };
    Transpiler.prototype.translateFile = function (fileName) {
        var host = this.createCompilerHost([fileName]);
        var program = ts.createProgram([fileName], OPTIONS, host);
        return this.translateProgram(program);
    };
    Transpiler.prototype.createCompilerHost = function (files) {
        var fileMap = {};
        files.forEach(function (f) { return fileMap[f] = true; });
        return {
            getSourceFile: function (sourceName, languageVersion) {
                // Only transpile the files directly passed in, do not transpile transitive dependencies.
                if (fileMap.hasOwnProperty(sourceName)) {
                    var contents = fs.readFileSync(sourceName, 'UTF-8');
                    return ts.createSourceFile(sourceName, contents, OPTIONS.target, true);
                }
                if (sourceName === 'lib.d.ts') {
                    return ts.createSourceFile(sourceName, '', OPTIONS.target, true);
                }
                return undefined;
            },
            writeFile: function (name, text, writeByteOrderMark) { fs.writeFile(name, text); },
            getDefaultLibFileName: function () { return 'lib.d.ts'; },
            useCaseSensitiveFileNames: function () { return true; },
            getCanonicalFileName: function (filename) { return filename; },
            getCurrentDirectory: function () { return ''; },
            getNewLine: function () { return '\n'; }
        };
    };
    // Visible for testing.
    Transpiler.prototype.getOutputPath = function (filePath, destinationRoot) {
        var relative = this.getRelativeFileName(filePath);
        var dartFile = relative.replace(/.(js|es6|ts)$/, '.dart');
        return path.join(destinationRoot, dartFile);
    };
    Transpiler.prototype.translate = function (sourceFile) {
        this.currentFile = sourceFile;
        this.output =
            new Output(sourceFile, this.getRelativeFileName(), this.options.generateSourceMap);
        this.errors = [];
        this.lastCommentIdx = -1;
        this.visit(sourceFile);
        if (this.errors.length) {
            var e = new Error(this.errors.join('\n'));
            e.name = 'TS2DartError';
            throw e;
        }
        return this.output.getResult();
    };
    Transpiler.prototype.getLibraryName = function (nameForTest) {
        var fileName = this.getRelativeFileName(nameForTest);
        var parts = fileName.split('/');
        return parts.filter(function (p) { return p.length > 0; })
            .map(function (p) { return p.replace(/[^\w.]/g, '_'); })
            .map(function (p) { return p.replace(/\.[jt]s$/g, ''); })
            .map(function (p) { return Transpiler.DART_RESERVED_WORDS.indexOf(p) != -1 ? '_' + p : p; })
            .join('.');
    };
    Transpiler.prototype.getRelativeFileName = function (absolute) {
        var filePath = absolute !== undefined ? absolute : this.currentFile.fileName;
        if (filePath.indexOf('/') !== 0)
            return filePath; // relative path.
        var base = this.options.basePath || '';
        if (filePath.indexOf(base) !== 0) {
            throw new Error("Files must be located under base, got " + filePath + " vs " + base);
        }
        return path.relative(this.options.basePath || '', filePath);
    };
    Transpiler.prototype.emit = function (s) { this.output.emit(s); };
    Transpiler.prototype.emitNoSpace = function (s) { this.output.emitNoSpace(s); };
    Transpiler.prototype.reportError = function (n, message) {
        var file = n.getSourceFile() || this.currentFile;
        var fileName = this.getRelativeFileName(file.fileName);
        var start = n.getStart(file);
        var pos = file.getLineAndCharacterOfPosition(start);
        // Line and character are 0-based.
        var fullMessage = fileName + ":" + (pos.line + 1) + ":" + (pos.character + 1) + ": " + message;
        if (this.options.failFast)
            throw new Error(fullMessage);
        this.errors.push(fullMessage);
    };
    Transpiler.prototype.visit = function (node) {
        var _this = this;
        this.output.addSourceMapping(node);
        var comments = ts.getLeadingCommentRanges(this.currentFile.text, node.getFullStart());
        if (comments) {
            comments.forEach(function (c) {
                if (c.pos <= _this.lastCommentIdx)
                    return;
                _this.lastCommentIdx = c.pos;
                var text = _this.currentFile.text.substring(c.pos, c.end);
                _this.emitNoSpace('\n');
                _this.emit(text);
                if (c.hasTrailingNewLine)
                    _this.emitNoSpace('\n');
            });
        }
        for (var i = 0; i < this.transpilers.length; i++) {
            if (this.transpilers[i].visitNode(node))
                return;
        }
        this.reportError(node, 'Unsupported node type ' + ts.SyntaxKind[node.kind] + ': ' +
            node.getFullText());
    };
    // For the Dart keyword list see
    // https://www.dartlang.org/docs/dart-up-and-running/ch02.html#keywords
    Transpiler.DART_RESERVED_WORDS = ('assert break case catch class const continue default do else enum extends false final ' +
        'finally for if in is new null rethrow return super switch this throw true try var void ' +
        'while with')
        .split(/ /);
    // These are the built-in and limited keywords.
    Transpiler.DART_OTHER_KEYWORDS = ('abstract as async await deferred dynamic export external factory get implements import ' +
        'library operator part set static sync typedef yield')
        .split(/ /);
    return Transpiler;
})();
exports.Transpiler = Transpiler;
var Output = (function () {
    function Output(currentFile, relativeFileName, generateSourceMap) {
        this.currentFile = currentFile;
        this.relativeFileName = relativeFileName;
        this.result = '';
        this.column = 1;
        this.line = 1;
        if (generateSourceMap) {
            this.sourceMap = new SourceMap.SourceMapGenerator({ file: relativeFileName + '.dart' });
            this.sourceMap.setSourceContent(relativeFileName, this.currentFile.text);
        }
    }
    Output.prototype.emit = function (str) {
        this.emitNoSpace(' ');
        this.emitNoSpace(str);
    };
    Output.prototype.emitNoSpace = function (str) {
        this.result += str;
        for (var i = 0; i < str.length; i++) {
            if (str[i] === '\n') {
                this.line++;
                this.column = 0;
            }
            else {
                this.column++;
            }
        }
    };
    Output.prototype.getResult = function () { return this.result + this.generateSourceMapComment(); };
    Output.prototype.addSourceMapping = function (n) {
        if (!this.sourceMap)
            return; // source maps disabled.
        var file = n.getSourceFile() || this.currentFile;
        var start = n.getStart(file);
        var pos = file.getLineAndCharacterOfPosition(start);
        var mapping = {
            original: { line: pos.line + 1, column: pos.character },
            generated: { line: this.line, column: this.column },
            source: this.relativeFileName
        };
        this.sourceMap.addMapping(mapping);
    };
    Output.prototype.generateSourceMapComment = function () {
        if (!this.sourceMap)
            return '';
        var base64map = new Buffer(JSON.stringify(this.sourceMap)).toString('base64');
        return '\n\n//# sourceMappingURL=data:application/json;base64,' + base64map;
    };
    return Output;
})();
// CLI entry point
if (require.main === module) {
    new Transpiler().transpile(process.argv.slice(2));
}

//# sourceMappingURL=main.js.map